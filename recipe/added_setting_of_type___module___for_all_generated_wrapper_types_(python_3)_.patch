Index: jcc3/sources/functions.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jcc3/sources/functions.cpp	(revision 1868526)
+++ jcc3/sources/functions.cpp	(revision 1868527)
@@ -1735,6 +1735,15 @@
         }
 
         PyModule_AddObject(module, name, (PyObject *) *type);
+
+        PyObject *module_name = PyModule_GetNameObject(module);
+
+        if (module_name != NULL)
+        {
+            PyObject_SetAttrString(
+                (PyObject *) *type, "__module__", module_name);
+            Py_DECREF(module_name);
+        }
     }
 }
 
Index: jcc3/sources/JArray.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jcc3/sources/JArray.cpp	(revision 1868526)
+++ jcc3/sources/JArray.cpp	(revision 1868527)
@@ -57,7 +57,15 @@
     static void dealloc(_t_iterator *self)
     {
         Py_XDECREF(self->obj);
+#if PY_VERSION_HEX >= 0x03080000
+        PyObject *type = Py_TYPE(self);
+#endif
+
         self->ob_base.ob_type->tp_free((PyObject *) self);
+
+#if PY_VERSION_HEX >= 0x03080000
+        Py_DECREF(type);
+#endif
     }
 
     static PyObject *iternext(_t_iterator *self)
@@ -124,7 +132,15 @@
 static void dealloc(U *self)
 {
     self->array = JArray<T>((jobject) NULL);
+#if PY_VERSION_HEX >= 0x03080000
+    PyObject *type = Py_TYPE(self);
+#endif
+
     self->ob_base.ob_type->tp_free((PyObject *) self);
+
+#if PY_VERSION_HEX >= 0x03080000
+    Py_DECREF(type);
+#endif
 }
 
 template<typename U>
Index: jcc3/sources/JCCEnv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jcc3/sources/JCCEnv.cpp	(revision 1868526)
+++ jcc3/sources/JCCEnv.cpp	(revision 1868527)
@@ -1008,11 +1008,11 @@
           case PyUnicode_1BYTE_KIND: {
               Py_ssize_t len = PyUnicode_GET_LENGTH(object);
               Py_UCS1 *pchars = PyUnicode_1BYTE_DATA(object);
-              std::vector<jchar> jchars((size_t) len, 0);
+              std::vector<jchar> jchars((size_t) len);
 
               for (std::vector<jchar>::iterator it = jchars.begin();
                    it != jchars.end(); ++it)
-                *it = (jchar) *(pchars++);
+                  *it = (jchar) *(pchars++);
 
               return get_vm_env()->NewString(jchars.data(), (size_t) len);
           }
Index: CHANGES
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- CHANGES	(revision 1868526)
+++ CHANGES	(revision 1868527)
@@ -1,6 +1,7 @@
 Version 3.6 ->
 ------------------
  - fixed bug with wrongly assuming 1BYTE_KIND python strings to be utf-8
+ - added setting of type.__module__ for all generated wrapper types (python 3)
  - 
 
 Version 3.5 -> 3.6
